---
interface Props {
  content: string;
  class?: string;
}

const { content, class: className = "" } = Astro.props;
---

<div class:list={["tooltip-trigger relative inline-block", className]} data-tooltip={content}>
  <slot />
</div>

<script>
  import { computePosition, autoPlacement, offset, arrow, shift, type Boundary } from "@floating-ui/dom";

  declare global {
    interface Window {
      tooltipInitialized: boolean;
    }
  }

  if (!window.tooltipInitialized) {
    window.tooltipInitialized = true;

    let activeTooltip: HTMLElement | null = null;
    let hideTimeout: number | null = null;
    let activeTarget: HTMLElement | null = null;

    function initTooltips() {
      const triggers = document.querySelectorAll("[data-tooltip]");

      triggers.forEach((trigger) => {
        trigger.addEventListener("mouseenter", handleMouseEnter as EventListener);
        trigger.addEventListener("mouseleave", handleMouseLeave as EventListener);
        trigger.addEventListener("touchstart", handleTouchStart as EventListener, {
          passive: false,
        });
      });
    }

    function handleMouseEnter(e: MouseEvent) {
      const trigger = e.currentTarget as HTMLElement;
      const content = trigger.getAttribute("data-tooltip");
      if (content) {
        activeTarget = trigger;
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
        showTooltip(trigger, content);
      }
    }

    function handleMouseLeave(e: MouseEvent) {
      const trigger = e.currentTarget as HTMLElement;
      const toElement = e.relatedTarget as HTMLElement;

      // 检查是否移动到 tooltip 上
      if (activeTooltip && (activeTooltip.contains(toElement) || toElement === activeTooltip)) {
        return;
      }

      // 检查是否在目标元素范围内
      const rect = trigger.getBoundingClientRect();
      const x = e.clientX;
      const y = e.clientY;

      const tolerance = 2;
      if (x >= rect.left - tolerance && x <= rect.right + tolerance && y >= rect.top - tolerance && y <= rect.bottom + tolerance) {
        return;
      }

      forceHideTooltip();
    }

    function forceHideTooltip() {
      if (activeTooltip) {
        activeTooltip.remove();
        activeTooltip = null;
      }
      activeTarget = null;
    }

    function handleTouchStart(e: TouchEvent) {
      e.preventDefault();

      // 如果已经有显示的 tooltip，直接隐藏并返回
      if (activeTooltip) {
        forceHideTooltip();
        return;
      }

      const trigger = e.currentTarget as HTMLElement;
      const content = trigger.getAttribute("data-tooltip");
      if (content) {
        showTooltip(trigger, content);
      }
    }

    async function showTooltip(trigger: HTMLElement, content: string) {
      if (activeTooltip) {
        activeTooltip.remove();
        activeTooltip = null;
      }

      const tooltip = document.createElement("div");
      tooltip.className =
        "tooltip-floating fixed z-50 px-2 py-1 text-xs bg-zinc-900 dark:bg-zinc-50 text-zinc-50 dark:text-zinc-900 rounded whitespace-nowrap pointer-events-none shadow-lg opacity-0 transition-opacity duration-200";
      tooltip.textContent = content;

      const arrowElement = document.createElement("div");
      arrowElement.className = "absolute bg-zinc-900 dark:bg-zinc-50";
      arrowElement.style.cssText = `
        width: 8px;
        height: 8px;
        transform: rotate(45deg);
        pointer-events: none;
      `;
      tooltip.appendChild(arrowElement);

      document.body.appendChild(tooltip);
      activeTooltip = tooltip;

      // 创建更新位置的函数
      const updatePosition = async () => {
        const { x, y, placement, middlewareData } = await computePosition(trigger, tooltip, {
          strategy: "fixed", // 使用fixed定位策略
          placement: "top",
          middleware: [
            offset(8),
            shift({
              padding: 5,
              boundary: document.body,
              // 添加滚动容器配置
              rootBoundary: "viewport",
            }),
            autoPlacement({
              allowedPlacements: ["top", "bottom"],
              boundary: document.body as Boundary,
            }),
            arrow({
              element: arrowElement,
              padding: 0,
            }),
          ],
        });

        // 获取目标元素的位置信息
        const triggerRect = trigger.getBoundingClientRect();
        const triggerCenter = {
          x: triggerRect.left + triggerRect.width / 2,
          y: triggerRect.top + triggerRect.height / 2,
        };

        Object.assign(tooltip.style, {
          left: `${x}px`,
          top: `${y}px`,
        });

        if (middlewareData.arrow) {
          const staticSide = {
            top: "bottom",
            bottom: "top",
          }[placement.split("-")[0]];

          // 计算箭头的精确位置
          const arrowLeft = triggerCenter.x - x - 4; // 4 是箭头宽度的一半

          Object.assign(arrowElement.style, {
            position: "absolute",
            left: `${arrowLeft}px`,
            [staticSide as string]: "-4px",
            margin: "0",
            zIndex: "1",
          });
        }
      };

      // 初始更新位置
      await updatePosition();

      // 添加滚动事件监听
      const scrollHandler = () => {
        if (activeTooltip === tooltip) {
          requestAnimationFrame(updatePosition);
        }
      };

      // 监听所有可能的滚动事件
      window.addEventListener("scroll", scrollHandler, { passive: true });
      document.addEventListener("scroll", scrollHandler, { passive: true });

      // 显示 tooltip
      requestAnimationFrame(() => {
        tooltip.classList.add("opacity-100");
      });

      // 清理函数
      const cleanup = () => {
        window.removeEventListener("scroll", scrollHandler);
        document.removeEventListener("scroll", scrollHandler);
      };

      // 在 tooltip 被移除时清理事件监听
      tooltip.addEventListener("remove", cleanup);
    }

    // 修改全局鼠标移动监听
    document.addEventListener(
      "mousemove",
      (e) => {
        if (!activeTooltip || !activeTarget) return;

        const rect = activeTarget.getBoundingClientRect();
        const tolerance = 2;

        if (
          e.clientX < rect.left - tolerance ||
          e.clientX > rect.right + tolerance ||
          e.clientY < rect.top - tolerance ||
          e.clientY > rect.bottom + tolerance
        ) {
          forceHideTooltip();
        }
      },
      { passive: true }
    );

    // 初始化
    document.addEventListener("DOMContentLoaded", initTooltips);
    document.addEventListener("astro:page-load", initTooltips);

    // 修改点击其他地方关闭tooltip的逻辑
    document.addEventListener(
      "touchstart",
      (e) => {
        if (activeTooltip && !(e.target as HTMLElement).closest("[data-tooltip]")) {
          e.preventDefault();
          forceHideTooltip();
        }
      },
      { passive: false }
    );
  }
</script>
